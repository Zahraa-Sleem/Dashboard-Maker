@{
	Layout = null;
}
<!DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" href="~/css/sideBar.css" />
	<link href="~/lib/font-awesome/css/fontawesome.css" rel="stylesheet" type="text/css" />
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<style>
		.flex-container {
			display: flex;
			flex-direction: row;
		}

		.sidebar {
			width: 20%;
		}

		#visualizationsContainer {
			width: 80%;
			overflow-x: auto; 
			white-space: nowrap; 
		}

		.graph {
			flex: 0 0 auto; /* Prevents graphs from shrinking */
			width: 300px;
			margin-right: 10px;
		}
	</style>
</head>
<body>

	<div class="flex-container">
		<div class="sidebar">
			<a class="active">Dashboard Maker</a>
			<select id="dashboardDropdown" style="width:80%;"></select>
			<a href="/Dashboard/Create"><i class="fa-solid fa-table-columns"></i> New Dashboard</a>
			<a href="/Visualization/Create" id="createVisualizationLink"><i class="fa fa-bar-chart"></i>New Visualization</a>
			<a href="/DataSource/Add"><i class="fa fa-database"></i>New Data Source</a>
		</div>

		<div id="visualizationsContainer" class="container-fluid">
			<div class="flex-row flex-nowrap" id="innerContainer">

			</div>
		</div>

	</div>

</body>
</html>
<script>
	document.addEventListener('DOMContentLoaded', function () {
		fetch('/api/Dashboard/GetUserDashboards')
			.then(response => {
				return response.json();
			})
			.then(data => {
				populateDropdown(data);
			})
			.catch(error => {
				console.error('Error fetching data:', error);
			});

		const dropdown = document.getElementById('dashboardDropdown');
		dropdown.addEventListener('change', function () {
			const selectedDashboardId = this.value;
			const createVisualizationLink = document.getElementById('createVisualizationLink');
			createVisualizationLink.href = '/Visualization/Create/' + selectedDashboardId;
			fetchAndDisplayVisualizations(selectedDashboardId);
			const container = document.getElementById('innerContainer');
			container.innerHTML = ''
		});

		function populateDropdown(data) {
			const dropdown = document.getElementById('dashboardDropdown');
			const option = new Option("Choose a dashboard", 0);
			dropdown.add(option);
			data.forEach(item => {
				const option = new Option(item.title, item.id);
				dropdown.add(option);
			});
		}

		function fetchAndDisplayVisualizations(dashboardId) {
			fetch(`/api/Visualization/GetByDashboard/${dashboardId}`)
				.then(response => response.json())
				.then(visualizations => {
					// Step 1: Save or process the visualization data
					// Step 2: Fetch additional data based on the visualizations
					visualizations.forEach(visualization => {
						getDataToBePlotted(visualization).then(Data => {
							// Step 3: Display data
							displayVisualizations(visualization, Data);
						});
					});
				})
				.catch(error => {
					console.error('Error fetching visualizations:', error);
				});
		}

		async function getDataToBePlotted(visualization) {
			try {
				const response = await fetch(`/api/Kata/GetDataForAGraph/${visualization.id}`);
				if (!response.ok) {
					throw new Error(`Network response was not ok: ${response.statusText}`);
				}

				const data = await response.json(); // Parse JSON response
				if (Array.isArray(data)) {
					// Assuming the data is an array of RowData objects
					return data.map(row => {
						if (!Array.isArray(row.columns)) {
							console.error('Row does not contain a Columns array:', row);
							return {}; 
						}

						return row.columns.reduce((obj, column) => {
							obj[column.columnName] = column.value;
							return obj;
						}, {});
					});
				} else {
					// Handle other responses like error messages
					console.error('Response is not in the expected format:', data);
					return [];
				}
			} catch (error) {
				console.error('There was a problem with your fetch operation:', error);
				throw error;
			}
		}


		function displayVisualizations(visualization, Data) {
			// Determine the type of visualization and render accordingly
			switch (visualization.visualizationTypeId) {
				case 2:
					renderLineChart(visualization, Data);
					break;
				case 1:
					renderBarChart(visualization, Data);
					break;
				case 3:
					renderPieChart(visualization, Data);
					break;
				default:
					console.error('Unsupported visualization type:', visualization.type);
			}
		}

		function renderLineChart(visualization, data) {
			addCanvasToContainer(visualization.id);
		}

		function renderBarChart(visualization, data) {
			// Create a canvas element and add it to div visualizationsContainer
			addCanvasToContainer(visualization.id);

			// Count the occurrences of data
			const occurrences = countOccurrences(data);

			// Extract labels and data for the chart
			const labels = Object.keys(occurrences);
			const chartData = Object.values(occurrences);

			// Get the context of the newly created canvas
			const ctx = document.getElementById(visualization.id).getContext('2d');

			// Generate a color for each item in the data
			const backgroundColors = labels.map(() => getRandomColor());
			const borderColors = backgroundColors.map(color => color.replace('0.5', '1'));

			// Create and draw the bar chart using Chart.js
			const myBarChart = new Chart(ctx, {
				type: 'bar',
				data: {
					labels: labels,
					datasets: [{
						label: visualization.title,
						data: chartData,
						backgroundColor: backgroundColors,
						borderColor: borderColors,
						borderWidth: 1
					}]
				},
				options: {
					scales: {
						y: {
							beginAtZero: true
						}
					}
				}
			});
		}

		function renderPieChart(visualization, data) {
			// Create a canvas element and add it to div visualizationsContainer
			addCanvasToContainer(visualization.id);

			// Count the occurrences of data
			const occurrences = countOccurrences(data);

			// Extract labels and data for the chart
			const labels = Object.keys(occurrences);
			const chartData = Object.values(occurrences);

			// Get the context of the newly created canvas
			const ctx = document.getElementById(visualization.id).getContext('2d');

			// Generate a color for each item in the data
			const backgroundColors = labels.map(() => getRandomColor());

			// Create and draw the pie chart using Chart.js
			const myPieChart = new Chart(ctx, {
				type: 'pie',
				data: {
					labels: labels,
					datasets: [{
						label: visualization.title,
						data: chartData,
						backgroundColor: backgroundColors,
						borderWidth: 1
					}]
				},
				options: {
					responsive: true,
					plugins: {
						legend: {
							position: 'top',
						},
						title: {
							display: true,
							text: visualization.title
						}
					}
				}
			});
		}

		function countOccurrences(data) {
			const counts = {};
			data.forEach(item => {
				// Assumes the first property of the object is the key
				const key = item[Object.keys(item)[0]];
				if (key === undefined) return; // Skip if the item is empty or doesn't have properties

				if (!counts[key]) {
					counts[key] = 0;
				}
				counts[key]++;
			});
			return counts;
		}



		function addCanvasToContainer(visualizationId) {
			// Create a new canvas element
			const canvas = document.createElement('canvas');

			// Assign the ID based on the visualization.id
			canvas.id = visualizationId;

			// Set the size of the canvas drawing area
			canvas.width = 300; 
			canvas.height = 300; 

			// Set the display size of the canvas via inline styles
			canvas.style.width = '300px';
			canvas.style.height = '300px';

			// Create a wrapper div for the canvas
			const graphDiv = document.createElement('div');
			graphDiv.classList.add('graph');
			graphDiv.classList.add('col-md-6');
			//graphDiv.classList.add('col-md-4');

			// Append the canvas to the wrapper div
			graphDiv.appendChild(canvas);

			// Create a delete button
			const deleteButton = document.createElement('button');
			deleteButton.innerText = 'Delete';
			deleteButton.classList.add('delete-btn');
			// Set the event listener for the delete button
			deleteButton.onclick = function () {
				// to be revisited
				// Remove the wrapper div from the container
				graphDiv.remove();
			};

			// Append the delete button to the wrapper div
			graphDiv.appendChild(deleteButton);

			// Find the container div by its ID and append the wrapper div to it
			const container = document.getElementById('innerContainer');
			container.appendChild(graphDiv);
		}

		function getRandomColor() {
			const r = Math.floor(Math.random() * 256);
			const g = Math.floor(Math.random() * 256);
			const b = Math.floor(Math.random() * 256);
			return `rgba(${r}, ${g}, ${b}, 0.5)`;
		}
	});
</script>

