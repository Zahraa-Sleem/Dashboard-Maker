@{
	Layout = null;
}
<!DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" href="~/css/sideBar.css" />
	<link href="~/lib/font-awesome/css/fontawesome.css" rel="stylesheet" type="text/css" />
</head>
<body>
	<div class="sidebar">
		<a class="active">Dashboard Maker</a>
		<select id="dashboardDropdown" style="width:80%;"></select>
		<a href="/Dashboard/Create"><i class="fa-solid fa-table-columns"></i> New Dashboard</a>
		<a href="/Visualization/Create" id="createVisualizationLink"><i class="fa fa-bar-chart"></i>New Visualization</a>
		<a href="/DataSource/Add"><i class="fa fa-database"></i>New Data Source</a>
	</div>

	<div id="visualizationsContainer"></div>

	<script src="~/lib/chart/chart.js"></script>
	<script>
		document.addEventListener('DOMContentLoaded', function () {
			fetch('/api/Dashboard/GetUserDashboards')
				.then(response => {
					return response.json();
				})
				.then(data => {
					populateDropdown(data);
				})
				.catch(error => {
					console.error('Error fetching data:', error);
				});

			const dropdown = document.getElementById('dashboardDropdown');
			dropdown.addEventListener('change', function () {
				const selectedDashboardId = this.value;
				const createVisualizationLink = document.getElementById('createVisualizationLink');
				createVisualizationLink.href = '/Visualization/Create/' + selectedDashboardId;
				fetchAndDisplayVisualizations(selectedDashboardId);
			});

			function populateDropdown(data) {
				const dropdown = document.getElementById('dashboardDropdown');
				const option = new Option("Choose a dashboard", 0);
				dropdown.add(option);
				data.forEach(item => {
					const option = new Option(item.title, item.id);
					dropdown.add(option);
				});
			}
		});


		function fetchAndDisplayVisualizations(dashboardId) {
			fetch(`/api/Visualization/GetByDashboard/${dashboardId}`)
				.then(response => response.json())
				.then(visualizations => {
					// Step 1: Save or process the visualization data
					// Step 2: Fetch additional data based on the visualizations
					visualizations.forEach(visualization => {
						getDataToBePlotted(visualization).then(Data => {
							// Step 3: Display data
							displayVisualizations(visualization, Data);
						});
					});
				})
				.catch(error => {
					console.error('Error fetching visualizations:', error);
				});
		}

		async function getDataToBePlotted(visualization) {
			try {
				const response = await fetch(`/api/Kata/GetDataForAGraph/${visualization.id}`);
				if (!response.ok) {
					throw new Error(`Network response was not ok: ${response.statusText}`);
				}

				const data = await response.json(); // Parse JSON response
				if (Array.isArray(data)) {
					// Assuming the data is an array of RowData objects
					return data.map(row => {
						if (!Array.isArray(row.columns)) {
							console.error('Row does not contain a Columns array:', row);
							return {}; // Return an empty object or handle this case as needed
						}

						return row.columns.reduce((obj, column) => {
							obj[column.columnName] = column.value;
							return obj;
						}, {});
					});
				} else {
					// Handle other responses like error messages
					console.error('Response is not in the expected format:', data);
					return []; // or throw an error, depending on your use case
				}
			} catch (error) {
				console.error('There was a problem with your fetch operation:', error);
				throw error;
			}
		}



		function displayVisualizations(visualization,Data) {
			// Determine the type of visualization and render accordingly
			switch (visualization.visualizationTypeId) {
				case 2:
					renderLineChart(visualization,Data);
					break;
				case 1:
					renderBarChart(visualization,Data);
					break;
				case 3:
					renderPieChart(visualization,Data);
					break;
				default:
					console.error('Unsupported visualization type:', visualization.type);
			}
		}

		function renderLineChart(visualization,data) {
			addCanvasToContainer(visualization.id);
		}

		function renderBarChart(visualization, data) 
		{
			// create a canvas element of id visualization.id
			// add this canvas to div visualizationsContainer
			addCanvasToContainer(visualization.id);

			// Count the occurrences of data
			const occurrences = countOccurrences(data);


			// Get the context of the newly created canvas
			const ctx = document.getElementById(visualization.id).getContext('2d');

			// Generate a color for each item in the data
		   const backgroundColors = Object.keys(occurrences).map(() => getRandomColor());
		   const borderColors = backgroundColors.map(color => color.replace('0.5', '1'));

			// Create and draw the bar chart using Chart.js
			const myBarChart = new Chart(ctx, {
				type: 'bar',
				data: {
					labels: Object.keys(occurrences),
					datasets: [{
						label: 'Number of Occurrences',
						data: Object.values(occurrences),
						backgroundColor: backgroundColors,
						borderColor: borderColors,
						borderWidth: 1
					}]
				},
				options: {
					scales: {
						y: {
							beginAtZero: true
						}
					}
				}
			});
		}

		function renderPieChart(visualization, data) {
			addCanvasToContainer(visualization.id);
		}

		function countOccurrences(data) {
			const counts = {};
			data.forEach(item => {
				const key = Object.keys(item)[0];
				if (key) {
					counts[key] = counts[key] || {};
					counts[key][item[key]] = (counts[key][item[key]] || 0) + 1;
				}
			});
			return counts;
		}

		function addCanvasToContainer(visualizationId) {
			// Create a new canvas element
			const canvas = document.createElement('canvas');

			// Assign the ID based on the visualization.id
			canvas.id = visualizationId;

			// Set some basic dimensions (optional, adjust as needed)
			canvas.width = 400; // example width
			canvas.height = 300; // example height

			// Find the container div by its ID and append the new canvas to it
			const container = document.getElementById('visualizationsContainer');
			container.appendChild(canvas);
		}

		function getRandomColor() {
			const r = Math.floor(Math.random() * 256);
			const g = Math.floor(Math.random() * 256);
			const b = Math.floor(Math.random() * 256);
			return `rgba(${r}, ${g}, ${b}, 0.5)`;
		}
	</script>
</body>
</html>

